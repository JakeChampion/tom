use events::Events;
use symbols;

grammar<E>(events: &mut E) where E: Events;

pub TomlFile: () = <kvs:KeyVal*> <ts:Table*>
    => events.reduce(symbols::FILE, kvs.len() + ts.len());

FileForm = {
    KeyVal, Table
};

KeyVal: () = KeyVal_ => events.reduce(symbols::KEY_VAL, 3);
KeyVal_ = {
   Key Eq Val
};

Key: () = Key_ => events.reduce(symbols::KEY, 1);
Key_ = { BareKey, BasicString, LiteralString };

Val: () = Val_ => events.reduce(symbols::VAL, 1);
Val_ = { Literal, Array, Dict };

Literal = {
    Number, Bool, DateTime,
    BasicString, MultilineBasicString,
    LiteralString, MultilineLiteralString,
};

Array: () = L_BRACK <xs:CommaList<Val>> R_BRACK
    => events.reduce(symbols::ARRAY, xs + 2);


Dict: () = L_CURLY <xs:CommaList<KeyVal>> R_CURLY
    => events.reduce(symbols::DICT, xs + 2);

Table: () = TableHeader <kvs:KeyVal*>
    => events.reduce(symbols::TABLE, 1 + kvs.len());

TableHeader: () = L_BRACK Key <keys:(Dot Key)*> R_BRACK
    => events.reduce(symbols::TABLE_HEADER, 3 + keys.len() * 2);

Eq: () = <l:@L> "=" <r:@R> => events.shift(symbols::EQ, l, r);
Dot: () = <l:@L> "." <r:@R> => events.shift(symbols::DOT, l, r);
Comma: () = <l:@L> "," <r:@R> => events.shift(symbols::COMMA, l, r);
L_BRACK: () = <l:@L> "[" <r:@R> => events.shift(symbols::L_BRACK, l, r);
R_BRACK: () = <l:@L> "]" <r:@R> => events.shift(symbols::R_BRACK, l, r);
L_CURLY: () = <l:@L> "{" <r:@R> => events.shift(symbols::L_CURLY, l, r);
R_CURLY: () = <l:@L> "}" <r:@R> => events.shift(symbols::R_CURLY, l, r);
Number: () = {
    <l:@L> number <r:@R> => events.shift(symbols::NUMBER, l, r),
    <l:@L> bare_key_or_number <r:@R> => events.shift(symbols::NUMBER, l, r),
};
DateTime: () = {
    <l:@L> date_time <r:@R> => events.shift(symbols::DATE_TIME, l, r),
    <l:@L> bare_key_or_date <r:@R> => events.shift(symbols::DATE_TIME, l, r),
};
Bool: () = <l:@L> bool <r:@R> => events.shift(symbols::BOOL, l, r);
BareKey: () = {
    <l:@L> bare_key <r:@R> => events.shift(symbols::BARE_KEY, l, r),
    <l:@L> bare_key_or_number <r:@R> => events.shift(symbols::BARE_KEY, l, r),
    <l:@L> bare_key_or_date <r:@R> => events.shift(symbols::BARE_KEY, l, r),
};

BasicString: () = <l:@L> basic_string <r:@R> =>
    events.shift(symbols::BASIC_STRING, l, r);
MultilineBasicString: () = <l:@L> multiline_basic_string <r:@R> =>
    events.shift(symbols::MULTILINE_BASIC_STRING, l, r);
LiteralString: () = <l:@L> literal_string <r:@R> =>
    events.shift(symbols::LITERAL_STRING, l, r);
MultilineLiteralString: () = <l:@L> multiline_literal_string <r:@R> =>
    events.shift(symbols::MULTILINE_LITERAL_STRING, l, r);


CommaList<T>: usize = {
    <v:(<T> Comma)*> <e:T?> => v.len() * 2 + e.into_iter().count(),
};


match {
    r"[0-9]+" => bare_key_or_number,
    r"[0-9]{4}-[0-9]{2}-[0-9]{2}[Zz]?" => bare_key_or_date,

    r#"(?x)
       "
        ([^\r\n"\\] | \\.)*
       "
    "# => basic_string,
    r#"(?x)
       """
        ([^"] | \\. | "[^"] | ""[^"])*
       """
    "# => multiline_basic_string,

    r#"(?x)
       '
        ([^\r\n'] | \\.)*
       '
    "# => literal_string,
    r#"(?x)
       '''
        ([^'] | \\. | '[^'] | ''[^'])*
       '''
    "# => multiline_literal_string,

    r"false|true" => bool,
} else {
    r"(?x)
      [-+]?
      (0|[1-9](_?[0-9])*) # no leading zeros
      (\.[0-9](_?[0-9])*)?
      ([eE][-+]?[1-9](_?[0-9])*)?
    " => number,
} else {
    r"(?x)
      ( [0-9]{4}-[0-9]{2}-[0-9]{2} ([Tt]([0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?))?
      | ([0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?))
      ([Zz]|[+-][0-9]{2}:[0-9]{2})?
    " => date_time,
    r"[0-9_\-a-zA-Z]+" => bare_key,
    _,
}

