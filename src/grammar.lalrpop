use events::Events;
use symbols;

grammar<E>(events: &mut E) where E: Events;

pub TomlFile: () = {
    <xs:FileForm*> => events.reduce(symbols::FILE, xs.len())
};

FileForm = {
    KeyVal
};

KeyVal: () = KeyVal_ => events.reduce(symbols::KEY_VAL, 3);
KeyVal_ = {
   Key Eq Val
};

Key: () = Key_ => events.reduce(symbols::KEY, 1);
Key_ = { BareKey };

Val: () = Val_ => events.reduce(symbols::VAL, 1);
Val_ = { Literal, Array, Dict };

Literal = { Number, Bool,
 BasicString, LiteralString,
 MultilineBasicString, MultilineLiteralString };

Array: () =
    L_BRACK <xs:CommaList<Val>> R_BRACK => events.reduce(symbols::ARRAY, xs + 2);


Dict: () =
    L_CURLY <xs:CommaList<KeyVal>> R_CURLY => events.reduce(symbols::DICT, xs + 2);

Eq: () = <l:@L> eq <r:@R> => events.shift(symbols::EQ, l, r);
Comma: () = <l:@L> comma <r:@R> => events.shift(symbols::COMMA, l, r);
L_BRACK: () = <l:@L> l_brack <r:@R> => events.shift(symbols::L_BRACK, l, r);
R_BRACK: () = <l:@L> r_brack <r:@R> => events.shift(symbols::R_BRACK, l, r);
L_CURLY: () = <l:@L> l_curly <r:@R> => events.shift(symbols::L_CURLY, l, r);
R_CURLY: () = <l:@L> r_curly <r:@R> => events.shift(symbols::R_CURLY, l, r);
Number: () = {
    <l:@L> number <r:@R> => events.shift(symbols::NUMBER, l, r),
    <l:@L> bare_key_or_number <r:@R> => events.shift(symbols::NUMBER, l, r),
};
Bool: () = <l:@L> bool <r:@R> => events.shift(symbols::BOOL, l, r);
BareKey: () = {
    <l:@L> bare_key <r:@R> => events.shift(symbols::BARE_KEY, l, r),
    <l:@L> bare_key_or_number <r:@R> => events.shift(symbols::BARE_KEY, l, r),
};

BasicString: () = <l:@L> basic_string <r:@R> =>
    events.shift(symbols::BASIC_STRING, l, r);
MultilineBasicString: () = <l:@L> multiline_basic_string <r:@R> =>
    events.shift(symbols::MULTILINE_BASIC_STRING, l, r);
LiteralString: () = <l:@L> literal_string <r:@R> =>
    events.shift(symbols::LITERAL_STRING, l, r);
MultilineLiteralString: () = <l:@L> multiline_literal_string <r:@R> =>
    events.shift(symbols::MULTILINE_LITERAL_STRING, l, r);


CommaList<T>: usize = {
    <v:(<T> Comma)*> <e:T?> => v.len() * 2 + e.into_iter().count(),
};


match {
    "=" => eq,
    "," => comma,
    "." => dot,
    "[" => l_brack,
    "]" => r_brack,
    "{" => l_curly,
    "}" => r_curly,
    r"[0-9]+" => bare_key_or_number,

    r#"(?x)
       "
        ([^\r\n"\\] | \\.)*
       "
    "# => basic_string,
    r#"(?x)
       """
        ([^"] | \\. | "[^"] | ""[^"])*
       """
    "# => multiline_basic_string,

    r#"(?x)
       '
        ([^\r\n'] | \\.)*
       '
    "# => literal_string,
    r#"(?x)
       '''
        ([^'] | \\. | '[^'] | ''[^'])*
       '''
    "# => multiline_literal_string,


    r"false|true" => bool,
} else {
    r"(?x)
      [-+]?
      (0|[1-9](_?[0-9])*) # no leading zeros
      (\.[0-9](_?[0-9])*)?
      ([eE][-+]?[1-9](_?[0-9])*)?
    " => number,
} else {
    r"[0-9_\-a-zA-Z]+" => bare_key,
}

